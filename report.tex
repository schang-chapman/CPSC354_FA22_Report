\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\usepackage{graphicx}
\graphicspath{ {./Images/} }

\usepackage{hyperref}

\title{CPSC-354 Report}
\author{Sharon Chang  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Placeholder  
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

Placeholder

\section{Homework}\label{homework}


\subsection{Week 1}

In order to familiarizae myself with LaTex, I was instructed to create a program to calculate the greatest common denominator of any two numbers in any programming language of my choice. I chose to write my GCD program in Python.

\begin{lstlisting}
def numInput():
    while True:
        numStr = input("Enter a number: ")
        try:
            num = int(numStr)
            if num > 0:
                return num
            else:
                print("The number must be greater than 0.")
                continue
        except:
            print("Invalid input.")

def gcd(numA, numB):
    if (numA > numB):
        result = gcd(numA-numB, numB)
    elif (numA < numB):
        result = gcd(numA, numB-numA)
    else:
        result = numA
    return result

# Main
numA = numInput()
print("First number acquired.")
numB = numInput()
print("Second number acquired.")

result = gcd(numA, numB)
print("The GCD of " + str(numA) + " and " + str(numB) + " is: " + str(result) + ".")
\end{lstlisting}
%
The numInput function first gets inputs from the user and makes sure that they are valid inputs to perform the gcd function on. The while loop traps the user until they input a valid non-zero integer. This repeats twice to obtain two numbers.

\medskip\noindent
After that, the two numbers are put into the gcd function. If number A is greater than number B, it recursively calls on the function again to find the GCD between the difference of A and B and number B. If number B is greater than number A, it recursively calls on the function again to find the GCD between number A and the difference of B and A. This repeats until the two numbers being compared are equal, after which the function returns the equal number. This equal number is the GCD of the two given numbers. This recursive function works because the method of subtraction will repeatedly lower the numbers until they inevitably equal out to yield a result.

\subsection{Week 2}

After familiarizing myself with LaTex, I then had to familiarize myself with Haskell. I created a series of recursive functions in Haskell which are listed below, followed by explanations for how they work.

\begin{lstlisting}
select_evens [] = []
select_evens (x:xs) | length (x:xs) >= 2 = (head xs) : (select_evens (tail xs))
                    | length (x:xs) == 1 = []
                    | otherwise = x:xs

select_odds [] = []
select_odds (x:xs) | length (x:xs) >= 1 = x : (select_odds (tail xs))
                   | otherwise = x:xs

member i [] = False
member i (x:xs) | i == x = True
                | otherwise = member i xs

append [] [] = []
append xs [] = xs
append [] ys = ys
append xs ys = head xs : (append (tail xs) ys)

revert [] = []
revert xs = append (revert (tail xs)) (head xs : [])

less_equal [] [] = True
less_equal xs [] = False
less_equal [] ys = True
less_equal xs ys | head xs <= head ys = less_equal (tail xs) (tail ys)
                 | otherwise = False
\end{lstlisting}
%
For my select evens function, I set the base case to return an empty list. The recursive function has 3 cases. In the first case, provided the given list has a length of 2 or greater, the head of the list xs is taken as the first element of the list. This is the second element of the given list because x is the head of list x:xs. After that the tail of the list xs is put back into select evens, which removes the first two elements from the list x:xs. In the second case, if the length of the list is 1, it also returns an empty list. Otherwise, it just returns the given list.

\begin{lstlisting}
select_evens [1,2,3,4,5] =
	2 : (select_evens [3,4,5]) =
	2 : 4 : (select_evens [5]) =
	2 : 4 : [] =
	[2,4]
\end{lstlisting}
%
My select odds function is similar to my select evens function, with a base case of an empty list. If the length of the given list is greater than or equal to 1, the head of list x:xs, which is the value x, is taken as the first element of the list. The tail is then passed back into select odds for the same reasons as the select evens function. If the length is too short, it returns the given list.

\begin{lstlisting}
select_odds [1,2,3,4,5] =
	1 : (select_odds [3,4,5]) =
	1 : 3 : (select_odds [5]) =
	1 : 3 : 5 : [] =
	[1,3,5]
\end{lstlisting}
%
The member function returns a base case of False given any input with an empty list. When given a list, as long as the list is greater than or equal to 1, it checks to see if the given input value matches the head of the given list. If it matches, it returns true, otherwise, it passes the tail of the list back into the member function.

\begin{lstlisting}
member 3 [1,2,3,4,5] =
	member 3 [2,3,4,5] =
	member 3 [3,4,5] =
	True
\end{lstlisting}
%
When given an empty set of lists, the append function returns an empty list. If only one of the given lists is empty, it returns the non-empty list. When given two non-empty lists, the head of the first list is taken as the first element of the list. It is attached to the resulting list from appending the tail of the first list with the whole of the second list. Eventually, this empties out the first list, which will cause the entirety of the second list to be appended onto the elements of the first list.

\begin{lstlisting}
append [1,2,3] [4,5,6] =
	1 : (append [2,3] [4,5,6]) =
	1 : 2 : (append [3] [4,5,6]) =
	1 : 2 : 3 : (append [] [4,5,6]) =
	1 : 2 : 3 : [4,5,6] =
	[1,2,3,4,5,6]
\end{lstlisting}
%
The base case of the revert function returns an empty list when given an empty list. When given a non-empty list, the revert function uses the previous append function to create a new list where the head of the given list is placed at the back. The remaining list elements are passed back into the revert function, which will result in a list where the elements are in reversed order.

\begin{lstlisting}
revert [1,2,3,4,5] =
	(append (revert [2,3,4,5])) : 1 : [] =
	(append (revert [2,3,4,5])) : [1] =
	(append (revert [3,4,5])) : 2 : [] : [1] =
	(append (revert [3,4,5])) : [2] : [1] =
	(append (revert [4,5])) : 3 : [] : [2] : [1] =
	(append (revert [4,5])) : [3] : [2] : [1] =
	(append (revert [5])) : 4 : [] : [3] : [2] : [1] =
	(append (revert [5])) : [4] : [3] : [2] : [1] =
	(append (revert [])) : 5 : [] : [4] : [3] : [2] : [1] =
	(append (revert [])) : [5] : [4] : [3] : [2] : [1] =
	[] : [5] : [4] : [3] : [2] : [1] =
	[5,4,3,2,1]
\end{lstlisting}
%
When the two lists given to the less equal function are both empty, the function returns a true. If the first list is non-empty but the second list is, the function returns false. If the second list is non-empty but the first one is, the function returns true. If both lists are non-empty lists, the head of both lists is compared to one another. If the head of the first list is less than or equal to the second list, the function continues by passing on the tails of both lists back into itself. Otherwise, if the head of the first list is greater than the head of the second list, the function stops and returns a false.

\begin{lstlisting}
less_equal [1,1,4] [1,2,3] =
	less_equal [1,4] [2,3] =
	less_equal [4] [3] =
	False
\end{lstlisting}

\subsection{Week 3}

The hanoi function takes 3 number inputs, which are the number of disks, the starting location, and the end location, in that order. It recursively calls on itself until the number of disks is reduced to one, upon which the move function is called. The move function has 2 inputs, the starting location and the ending location. It only moves the topmost disk of that location.

\medskip\noindent
The following demonstrates the hanoi and move functions as mathematical equations.

\begin{align*}
{\rm hanoi} (1) (x) (y)
& = {\rm move}(x)(y)
\end{align*}
\begin{align*}
{\rm hanoi} (n+1) (x) (y)
& = {\rm hanoi} (n) (x) ({\rm other}(x)(y)) \\
& = {\rm move}(x)(y)\\
& = {\rm hanoi} (n) ({\rm other}(x)(y)) (y)
\end{align*}

\medskip\noindent
The following code demonstrates the recursive steps used when executing a function to solve a Hanoi tower problem of 5 disks.

\begin{lstlisting}
hanoi 5 0 2
	hanoi 4 0 1
		hanoi 3 0 2
			hanoi 2 0 1
				hanoi 1 0 2 = move 0 2
				move 0 1
				hanoi 1 2 1 = move 2 1
			move 0 2
			hanoi 2 1 2
				hanoi 1 1 0 = move 1 0
				move 1 2
				hanoi 1 0 2 = move 0 2
		move 0 1
		hanoi 3 2 1
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
			move 2 1
			hanoi 2 0 1
				hanoi 1 0 2 = move 0 2
				move 0 1
				hanoi 1 2 1 = move 2 1
	move 0 2
	hanoi 4 1 2
		hanoi 3 1 0
			hanoi 2 1 2
				hanoi 1 1 0 = move 1 0
				move 1 2
				hanoi 1 0 2 = move 0 2
			move 1 0
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
		move 1 2
		hanoi 3 0 2
			hanoi 2 0 1
				hanoi 1 0 2 = move 0 2
				move 0 1
				hanoi 1 2 1 = move 2 1
			move 0 2
			hanoi 2 1 2
				hanoi 1 1 0 = move 1 0
				move 1 2
				hanoi 1 0 2 = move 0 2
\end{lstlisting}
%
These instructions count the leftmost pole as the Pole 1, the middle pole as Pole 2, and the rightmost pole as Pole 3.

\medskip\noindent
Move the top disk from Pole 1 to Pole 3. Next, move the next top disk from Pole 1 to Pole 2. Take the top disk from Pole 3 and move it to Pole 2. Then, move the top disk from Pole 1 to Pole 3. Follow by moving the top from Pole 2 to Pole 1. Then, move the top disk from Pole 2 to Pole 3. Afterwards, move the top disk from Pole 1 to Pole 3. Move the next top disk from Pole 1 to Pole 2. Next, take the top disk from Pole 3 and move it to Pole 2. Take the next top disk from Pole 3 and move it to Pole 1. Then, take the top disk from Pole 2 and move it to Pole 1. Follow by moving the top disk from Pole 3 to Pole 2. Next, move the top disk from Pole 1 to Pole 3. Then, move the next top disk from Pole 1 to Pole 2. Return to the top disk of Pole 3 and move it to Pole 2. Now, take the top disk of Pole 1 and move it to Pole 3. Next, take the top disk from Pole 2 and move it to Pole 1. Then, take the top disk from Pole 2 and move it to Pole 3. Follow by taking the top disk from Pole 1 and moving it to Pole 3. Return to Pole 2 and move its top disk to Pole 1. Now, take the top disk from Pole 3 and move it to Pole 2. Next, take the top disk from Pole 3 and move it to Pole 1. Then, take the top disk from Pole 2 and move it to Pole 1. Take the next top disk from Pole 2 and move it to Pole 3. Now, take the top disk from Pole 1 and move it to Pole 3. Return to the next top disk from Pole 1 and move it to Pole 2. Then, take the top disk from Pole 3 and move it to Pole 2. Next, take the top disk from Pole 1 and move it to Pole 3. Then, take the top disk from Pole 2 and move it to Pole 1. Move the next top disk from Pole 2 to Pole 3. Then, take the top disk from Pole 1 and move it to Pole 3. A 5-disk Tower of Hanoi has now been successfully moved from Pole 1 to Pole 3.

\medskip\noindent
The word hanoi appears 31 times in the computation.

\subsection{Week 4}

The following demonstrates the syntax trees for various arithmetic expressions. The expression being demonstrated is at the top right corner of each section, with two trees below it. The right tree is the concrete syntax tree, and the left is the abstract syntax tree.

\includegraphics {hw4}

\subsection{Week 5}

There is a folder called "hw5" in the repository that this folder is contained in. Using the grammar and interpreter contained within, I generated linearized abstract syntax trees for various Lambda expressions, then made 2D trees of them as seem below.

\begin{center}
\includegraphics[width=\linewidth]{hw5p1}
\includegraphics[width=\linewidth]{hw5p2}
\end{center}

\medskip\noindent
Additionally, the following includes examples of various lambda expressions evaluated by hand.

\begin{lstlisting}
Expression: (\x.x) a =
a
\end{lstlisting}

\begin{lstlisting}
Expression: \x.x a =
\x.x a
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) a b =
(\y.a) b =
a
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) a b =
(\y.y) b =
b
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) a b c =
(\y.a) b c =
(a) c =
a c
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) a b c =
(\y.y) b c =
(b) c =
b c
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) a (b c) =
(\y.a) (b c) =
a
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) a (b c) =
(\y.y) (b c) =
b c
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) (a b) c =
(\y.(a b)) c =
(a b) =
a b
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) (a b) c =
(\y.y) c =
c
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) (a b c) =
(\y.(a b c)) =
\y.(a b c)
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) (a b c) =
(\y.y) =
\y.y
\end{lstlisting}
%
Now, I will demonstrate how the interpreter from LambdaNat0 of Assignment 2 (also found in the same repository as this report) evaluates Lambda expressions via the evalCBN function. Each step is accompanied by the line number of the Interpreter.hs code that performs that step.

\begin{lstlisting}
evalCBN ((\x.x)((\y.y)a)) = 
evalCBN (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "a")))) = Line 13
evalCBN (subst (Id "x") (EAbs (Id "y") (EVar (Id "a"))) (EVar (Id "x"))) = Line 67
evalCBN (EAbs (Id "y") (EVar (Id "a"))) = Line 13
evalCBN (subst (Id "y") (EVar (Id "a")) (EVar (Id "y"))) = Line 64
evalCBN a = Line 50
a
\end{lstlisting}

\subsection{Week 6}

The following demonstrates the evaluation of the exponent expression 2$^3$.

\begin{lstlisting}
(\exp . \two . \three . exp two three)
(\m.\n. m n)
(\f.\x. f (f x))
(\f.\x. f (f (f x)))
=
(\m.\n. m n) (\f.\x. f (f x)) (\f2.\x2. f2 (f2 (f2 x2)))
=
(\n. (\f.\x. f (f x)) n) (\f2.\x2. f2 (f2 (f2 x2)))
=
((\f.\x. f (f x)) (\f2.\x2. f2 (f2 (f2 x2))))
=
((\x. (\f2.\x2. f2 (f2 (f2 x2))) ((\f2.\x2. f2 (f2 (f2 x2))) x)))
=
((\x. (\x2. ((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2)))))
=
(\x. (\x2. ((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))
=
(\x. (\x2. ((\x2. x (x (x x2)))) (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))
=
(\x. (\x2. (\x2. x (x (x x2))) (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))
=
(\x. (\x2. (x (x (x (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2)))))))
=
(\x. (\x2. (x (x (x (((\x2. x (x (x x2)))) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2)))))))
=
(\x. (\x2. (x (x (x ((\x2. x (x (x x2))) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2)))))))
=
(\x. (\x2. (x (x (x ((x (x (x (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))))))))
=
(\x. (\x2. (x (x (x (x (x (x (((\f2.\x2. f2 (f2 (f2 x2))) x) x2)))))))))
=
(\x. (\x2. (x (x (x (x (x (x (((\x2. x2 (x2 (x2 x2))) x))))))))))
=
(\x. (\x2. (x (x (x (x (x (x (((x (x (x x)))))))))))))
=
(\x. (\x2. (x (x (x (x (x (x (x (x (x x)))))))))))
\end{lstlisting}

\subsection{Week 7}

Returning to the evalCBN function in LambdaNat0 of Assignment 2, I will now examine the variables of that function.

\medskip\noindent
In line 5 the variables e1 and e2 are bound on the left of the equal sign with their scope being the body of the evalCBN function (through the end of line 7). The variables i and e3 in line 6 are bound on the left of the arrow sign and their scope is to the end of that line. Similarly, in line 7, e3 is bound to the left of the arrow sign and the scope is also to the end of that line. In line 8, x is then bound to the left of the equal sign and its scope is the end of line 8.

\medskip\noindent
In line 18 the variables id, id1, e1, and s are bound on the left of the equal sign with the scope being body of the subst function (through the end of line 22). The variable f in line 20 is also bound to the left of its equal sign. The variable e2 in line 21 is also bound to the left of its equal sign. Both f and e2 have scopes reaching the end of line 22.

\medskip\noindent
The following demonstrates an example of the the evalCBN function at work using abstract syntax in the same manner as demonstrated in the section Week 5. The line numbers refer to Interpreter-fragment.hs within LambdaNat0 this time.

\begin{lstlisting}
evalCBN ((\x.\y.x) y z) =
evalCBN ((EAbs (Id "x") (EAbs (Id "y") EVar (Id "x"))) EVar (Id "y") EVar (Id "z")) = Line 6
evalCBN (subst (Id "x") (EVar (Id "y")) (EAbs (Id "y") EVar (Id "x")) = Line 18
evalCBN (EAbs (Id "a") (EVar (Id "y"))) = Line 21
evalCBN ((EAbs (Id "a") (EVar (Id "y"))) (EVar (Id "z"))) = Line 22
evalCBN (subst (EVar (Id "a")) (EVar (Id "z")) (EVar (Id "y))) = Line 6
evalCBN (EVar (Id "z")) = Line 15
z
\end{lstlisting}
%
The following demonstrates the various properties of abstract reduction sequences.

\begin{center}
\includegraphics[width=\linewidth]{hw7a}
\end{center}
%
Here are examples fulfilling every combination of ARS properties, where possible.

\begin{center}
\includegraphics[width=\linewidth]{hw7b}
\end{center}

\subsection{Week 8}
The following section is an analysis on the ARS system seen below.

\begin{lstlisting}
aa -> a
bb -> b
ba -> ab
ab -> ba
\end{lstlisting}
%
This ARS does not terminate on account of the last two rules. These rules can infinitely loop into each other, forming the following computation.

\begin{lstlisting}
ba -> ab -> ba -> ...
\end{lstlisting}
%
This ARS has 3 normal forms where the computation can no longer be reduced. These forms are a, b, and [] (empty list).

\medskip\noindent
In order to modify the ARS to make it terminate, I need to introduce a fourth normal form. By editing the ARS to the form below, the ARS now terminates and has the unique normal forms a, b, [], and ab.

\begin{lstlisting}
aa -> a
bb -> b
ba -> ab
ab -> ab
\end{lstlisting}
%
This modified ARS now terminates and breaks the loop created by the original ruleset. This maintains the equivalency relationship from the original rules as well, as seen below.

\begin{lstlisting}
Original:
ba -> ab -> ...
ab -> ba -> ab -> ...

Modified:
ba -> ab -> ab
\end{lstlisting}
%
Looking at the 4 normal forms a, b, [], and ab, I can find specification being implemented by the ARS. The normal form a has the invariant that there is at least one a in the input. The normal form b has the same invariant, but for there being at least one b. The empty string results from there being no a or b. Then, there is the normal form ab, which results from the combination of either ba or ab. That is, the invariant that there is at least one a and b. These invariants communicate that this ruleset decides whether the input is empty, has "a"s but no "b"s, "b"s but no "a"s, or has both "a"s and "b"s.

\subsection{Week 9}
For my final project, the two major parts will be the list generating functions and the list arithmetic functions. My milestones will be as follows:

\medskip\noindent
November 13th: Complete the 4 list generating functions (triangle, cube, square, and fibonacci)

\medskip\noindent
December 4th: Complete the list artihmetic functions, but at this point they will only work with lists of the same length

\medskip\noindent
December 11th: Figure out how to make lists of different lengths compatible in my arithmetic functions.

\medskip\noindent This schedule will give me all of finals week to do any final edits that need to be made and complete the report details.

\medskip\noindent
I will now analyze the following ARS.

\begin{lstlisting}
ba -> ab
ab -> ba
ac -> ca
ca -> ac
bc -> cb
cb -> bc

aa -> b
ab -> c
ac ->  
bb ->
cb -> a
cc -> b
\end{lstlisting}
%
By drawing the rules out, the properties of the ARS become apparent.

\begin{center}
\includegraphics{hw9}
\end{center}
%
This ARS is non-terminating because the loops formed by ab, ba, ac, ca, bc, and cb can run forever. It is also non-confluent as there are no visible peaks or valleys formed by connecting the rules together. The ARS also does not have unique normal forms. The normal forms here are c, [] (empty), a, and b, but the normal forms [] and b are both shared between multiple rules.

\medskip\noindent
The invariants of this ARS are:

\begin{itemize}
\item {Any pair of letters with the letter b and a different letter will evaluate into the missing third letter}
\item {Any pair of two of the same letter that is not the letter b will evalate into the letter b}
\item {Any exceptions to the above two rules will evaluate into empty}
\end{itemize}

\subsection{Week 10}
The following code demonstrates the computation steps for the factorial function $fix_F$2.
\begin{lstlisting}
fix F 2 = (def of fix)
F (fix F) 2 = (def of F)
???
2
\end{lstlisting}

\subsection{Week 11}
The following short essay discusses \href{https://www.cs.tufts.edu/~nr/cs257/archive/simon-peyton-jones/contracts.pdf}{this paper} on a prototype for a programming language based on writing and implementing contracts.

\medskip\noindent
A tailor-made language for writing and executing contracts would open the door to creating specialized contract creation tools. Similar to specialized languages, such as SQL being a database language, it helps to have a specialized tool one can use that is built to handle a specific purpose. Even if it is not perfect, it could still be used to handle common, simple contracts. Having a preexisting groundwork also helps to build more complicated projects on top of it later on. Additionally, because current contracts are lengthy pieces of writing, to make a program that could successfully replace that could perhaps be a step towards better natural language processing.

\medskip\noindent
However, while I feel that a specialized contract language could be useful, computers would likely be severely limited in the types of contracts they can interpret. Contracts that rely on hard concepts such as "payment of X amount by Y date" could be easily run through a computer. However, when accounting for human error, computer-run contract systems must be extremely complex to keep up. Payment contracts, such as rent, are not often subject to late or partial payments. A human administrator would be able to provide the necessary leeway for such circumstances, but a computer is unlikely to care. One could use a program to retroactively inform the computer that an unwritten change was made to the contract, but with how common such scenarios are, this might be introducing unnecessary complexity to the situation.

\medskip\noindent
Similarly, contracts that rely on abstract concepts, such as NDAs, would be difficult to administer via a computer program. A computer would be unable to understand the concept of information leaking and would be unreliable in enforcing an NDA as a contract. In the same vein, many contracts rely on multiple conditions that can overlap and affect other conditions, ultimately affecting the outcome. Lawyers are specially trained to learn how to parse contracts, which are often beyond the scope of understanding for normal people. Contracts of such complexity, which are already a challenge for human understanding, would pose a great obstacle for a computer to parse via a programming language. One would have to conduct an order of operations for conditions that are flexible enough to work with a wide range of contracts.

\medskip\noindent
However, because of this complexity issue, should this project succeed, it would open the possibility for contract parsing to become more open to the general public. Not everyone is a lawyer, and not everyone has one on hand. Given the prolific nature of contracts in the online world, from agreeing to be subject to tracking cookies or signing up for a new website, having a computer program that could parse any given contract and reduce it to understandable terms would be very useful. Making the language of contracts more accessible could also change how lawyers and contract writers approach writing contracts, as the parser would make it impossible for them to obfuscate their intentions through complicated language. This development could force transparency upon these institutions and, in turn, generate more fair contracts for the general population.

\subsection{Week 12}
The following section demonstrates Hoare logic analysis as applied to the code below.

\begin{lstlisting}
while (x!=0) do z:=z*y;  x:= x-1 done
\end{lstlisting}
%
We know that the program must terminate because the condition of the while loop is x not equaling 0, which x will inevitably reach on account of it being decremented with each loop. Let us assume that the variables are initialized as x = 100, y = 2, and z = 1. We will treat the variable t as a count for how many times the loop has been executed. It follows that x + t must always equal 100, as x is decremented by 1 while t is incremented by 1 with each loop. The variable y is never edited during the loop, so it will always stay at 2. The variable z is multiplied by y with each loop, being initialized as 1 but increasing to 2, then 4, then 8, then 16, and so on and so forth until the loop completes itself. This pattern reflects the exponents of 2, therefore one can write the relationship between z and y as z = y$^t$. This gives us two equations to work with.

\begin{align*}
t + x = 100
\end{align*}
\begin{align*}
z = y^t
\end{align*}
%
Logically, we can put these equations to yield a single invariant equation.

\begin{align*}
z = y^{(100 - x)}
\end{align*}
%
Now that we have the invariant, we will move on to discuss the preconditions and postconditions of our example code. The precondition of this loop running is that x must equal some positive integer above 0 and z must equal 1. The equation presented above is our postcondition that results from the termination of our program. It is worth noting that the 100 in our above invariant equation is merely a stand-in for whatever value x is initialized with. This results in the following Hoare triple.

\begin{align*}
\{x \ge 0 \: \Lambda \: z = 1\} \; {\rm while} \: (x!=0) \: {\rm do} \: z:=z*y; \: x:= x-1 \: {\rm done} \; \{z = y^x\}
\end{align*}
%
However, this only accounts for certain values of x and z. Taking the prior example initialization values of x = 100 and y = 2 but changing z to z =  5, we would see the pattern of 10, 20, 40, etc. One sees that this pattern reflects the earlier pattern except everything is now multiplied by 5. Therefore, it is better rewritten as follows to account for the variables having different values.

\begin{align*}
\{x = a \: \Lambda \: y = b \: \Lambda \: z = c\} \; {\rm while} \: (x!=0) \: {\rm do} \: z:=z*y; \: x:= x-1 \: {\rm done} \; \{z = c * b^a\}
\end{align*}
%
The following lines demonstrate the proof tree demonstrates the above steps in Hoare logic:
\begin{align*}
\{z*y = c * y^{(a - (x-1))} \: \Lambda \: y = b\} \; z:= z*y \; \{z = c * y^{(a - (x-1))} \: \Lambda \: y = b\} \; x:=x-1 \; \{z =c * y^{(a - x)} \: \Lambda \: y = b\}
\end{align*}
\begin{align*}
\{z = c * y^{(a - (x))} \: \Lambda \: y = b \: \Lambda \: x \neq 0\} \; z:= z*y; \: x:=x-1 \;  \{z =c * y^{(a - x)} \: \Lambda \: y = b\}
\end{align*}
\begin{align*}
 \{z =c * y^{(a - x)} \: \Lambda \: y = b\} \; {\rm while} \: (x!=0) \: {\rm do} \: z:=z*y; \: x:= x-1 \: {\rm done} \; \{x=0 \: \Lambda \: z =c * y^{(a - x)} \: \Lambda \: y = b\}
\end{align*}
\begin{align*}
\{x = a \: \Lambda \: y = b \: \Lambda \: z = c\} \; {\rm while} \: (x!=0) \: {\rm do} \: z:=z*y; \: x:= x-1 \: {\rm done} \; \{z = c * b^a\}
\end{align*}

\section{Project}

The final project I have created goes into the variety of methods with which Haskell allows the user to create and manipulate infinite lists. My project is centered around mathematical patterns, with functions that generate various patterns as lists and other functions that can then manipulate them.

\subsection{Specification}
My project uses infinite lists in Haskell in order to generate lists of variable size and manipulate them. There are a variety of sequences in math similar to the Fibonacci sequence, and I will implement them as separate functions. The sequences being implemented will be arithmetic, geometric, triangular, square, cube, and Fibonacci.

\medskip\noindent
Triangle, cube, square, and Fibonacci work by taking in 1 integer number and generating a list of the sequence with the length of the given integer. For example, (fib 5) generates a list containing the first 5 Fibonacci numbers. Arithmetic and geometric take in 3 integer numbers. The first integer works the same as the other sequences, where it dictates the list's length. The 2nd number is the first entry of the list and the 3rd number is the number added to each entry. For example, (arit 3 1 6) produce the list [1, 7, 13]. In geometric, the 2nd number works the same but the 3rd number is the number multiplied against the given value to continue the list. For example, (geo 3 1 6) produces the list [1, 6, 36].

\medskip\noindent
These lists can have mathematical operations performed between them, which will result in a new list. The available operations are addition, subtraction, multiplication, and integer division. When performing mathematical operations between lists of different lengths, the resulting list will be the length of the longer list. The shorter list will be extended with 0 values to fill it out to match the length of the longer list. For example, adding the lists [2, 4, 8, 16] and the list [1, 2, 3] is the same as adding the lists [2, 4, 8, 16] and [1, 2, 3, 0], resulting in the list [3, 6, 11, 16].

\subsection{Prototype}

Placeholder

\subsection{Documentation}

Placeholder

\subsection{Critical Appraisal}

Placeholder

\section{Conclusions}\label{conclusions}

Placeholder

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\end{thebibliography}

\end{document}
\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\usepackage{graphicx}
\graphicspath{ {./Images/} }


\title{CPSC-354 Report}
\author{Sharon Chang  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Placeholder  
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

Placeholder

\section{Homework}\label{homework}


\subsection{Week 1}

In order to familiarizae myself with LaTex, I was instructed to create a program to calculate the greatest common denominator of any two numbers in any programming language of my choice. I chose to write my GCD program in Python.

\begin{lstlisting}
def numInput():
    while True:
        numStr = input("Enter a number: ")
        try:
            num = int(numStr)
            if num > 0:
                return num
            else:
                print("The number must be greater than 0.")
                continue
        except:
            print("Invalid input.")

def gcd(numA, numB):
    if (numA > numB):
        result = gcd(numA-numB, numB)
    elif (numA < numB):
        result = gcd(numA, numB-numA)
    else:
        result = numA
    return result

# Main
numA = numInput()
print("First number acquired.")
numB = numInput()
print("Second number acquired.")

result = gcd(numA, numB)
print("The GCD of " + str(numA) + " and " + str(numB) + " is: " + str(result) + ".")
\end{lstlisting}
%
The numInput function first gets inputs from the user and makes sure that they are valid inputs to perform the gcd function on. The while loop traps the user until they input a valid non-zero integer. This repeats twice to obtain two numbers.

\medskip\noindent
After that, the two numbers are put into the gcd function. If number A is greater than number B, it recursively calls on the function again to find the GCD between the difference of A and B and number B. If number B is greater than number A, it recursively calls on the function again to find the GCD between number A and the difference of B and A. This repeats until the two numbers being compared are equal, after which the function returns the equal number. This equal number is the GCD of the two given numbers. This recursive function works because the method of subtraction will repeatedly lower the numbers until they inevitably equal out to yield a result.

\subsection{Week 2}

After familiarizing myself with LaTex, I then had to familiarize myself with Haskell. I created a series of recursive functions in Haskell which are listed below, followed by explanations for how they work.

\begin{lstlisting}
select_evens [] = []
select_evens (x:xs) | length (x:xs) >= 2 = (head xs) : (select_evens (tail xs))
                    | length (x:xs) == 1 = []
                    | otherwise = x:xs

select_odds [] = []
select_odds (x:xs) | length (x:xs) >= 1 = x : (select_odds (tail xs))
                   | otherwise = x:xs

member i [] = False
member i (x:xs) | i == x = True
                | otherwise = member i xs

append [] [] = []
append xs [] = xs
append [] ys = ys
append xs ys = head xs : (append (tail xs) ys)

revert [] = []
revert xs = append (revert (tail xs)) (head xs : [])

less_equal [] [] = True
less_equal xs [] = False
less_equal [] ys = True
less_equal xs ys | head xs <= head ys = less_equal (tail xs) (tail ys)
                 | otherwise = False
\end{lstlisting}
%
For my select evens function, I set the base case to return an empty list. The recursive function has 3 cases. In the first case, provided the given list has a length of 2 or greater, the head of the list xs is taken as the first element of the list. This is the second element of the given list because x is the head of list x:xs. After that the tail of the list xs is put back into select evens, which removes the first two elements from the list x:xs. In the second case, if the length of the list is 1, it also returns an empty list. Otherwise, it just returns the given list.

\begin{lstlisting}
select_evens [1,2,3,4,5] =
	2 : (select_evens [3,4,5]) =
	2 : 4 : (select_evens [5]) =
	2 : 4 : [] =
	[2,4]
\end{lstlisting}
%
My select odds function is similar to my select evens function, with a base case of an empty list. If the length of the given list is greater than or equal to 1, the head of list x:xs, which is the value x, is taken as the first element of the list. The tail is then passed back into select odds for the same reasons as the select evens function. If the length is too short, it returns the given list.

\begin{lstlisting}
select_odds [1,2,3,4,5] =
	1 : (select_odds [3,4,5]) =
	1 : 3 : (select_odds [5]) =
	1 : 3 : 5 : [] =
	[1,3,5]
\end{lstlisting}
%
The member function returns a base case of False given any input with an empty list. When given a list, as long as the list is greater than or equal to 1, it checks to see if the given input value matches the head of the given list. If it matches, it returns true, otherwise, it passes the tail of the list back into the member function.

\begin{lstlisting}
member 3 [1,2,3,4,5] =
	member 3 [2,3,4,5] =
	member 3 [3,4,5] =
	True
\end{lstlisting}
%
When given an empty set of lists, the append function returns an empty list. If only one of the given lists is empty, it returns the non-empty list. When given two non-empty lists, the head of the first list is taken as the first element of the list. It is attached to the resulting list from appending the tail of the first list with the whole of the second list. Eventually, this empties out the first list, which will cause the entirety of the second list to be appended onto the elements of the first list.

\begin{lstlisting}
append [1,2,3] [4,5,6] =
	1 : (append [2,3] [4,5,6]) =
	1 : 2 : (append [3] [4,5,6]) =
	1 : 2 : 3 : (append [] [4,5,6]) =
	1 : 2 : 3 : [4,5,6] =
	[1,2,3,4,5,6]
\end{lstlisting}
%
The base case of the revert function returns an empty list when given an empty list. When given a non-empty list, the revert function uses the previous append function to create a new list where the head of the given list is placed at the back. The remaining list elements are passed back into the revert function, which will result in a list where the elements are in reversed order.

\begin{lstlisting}
revert [1,2,3,4,5] =
	(append (revert [2,3,4,5])) : 1 : [] =
	(append (revert [2,3,4,5])) : [1] =
	(append (revert [3,4,5])) : 2 : [] : [1] =
	(append (revert [3,4,5])) : [2] : [1] =
	(append (revert [4,5])) : 3 : [] : [2] : [1] =
	(append (revert [4,5])) : [3] : [2] : [1] =
	(append (revert [5])) : 4 : [] : [3] : [2] : [1] =
	(append (revert [5])) : [4] : [3] : [2] : [1] =
	(append (revert [])) : 5 : [] : [4] : [3] : [2] : [1] =
	(append (revert [])) : [5] : [4] : [3] : [2] : [1] =
	[] : [5] : [4] : [3] : [2] : [1] =
	[5,4,3,2,1]
\end{lstlisting}
%
When the two lists given to the less equal function are both empty, the function returns a true. If the first list is non-empty but the second list is, the function returns false. If the second list is non-empty but the first one is, the function returns true. If both lists are non-empty lists, the head of both lists is compared to one another. If the head of the first list is less than or equal to the second list, the function continues by passing on the tails of both lists back into itself. Otherwise, if the head of the first list is greater than the head of the second list, the function stops and returns a false.

\begin{lstlisting}
less_equal [1,1,4] [1,2,3] =
	less_equal [1,4] [2,3] =
	less_equal [4] [3] =
	False
\end{lstlisting}

\subsection{Week 3}

The hanoi function takes 3 number inputs, which are the number of disks, the starting location, and the end location, in that order. It recursively calls on itself until the number of disks is reduced to one, upon which the move function is called. The move function has 2 inputs, the starting location and the ending location. It only moves the topmost disk of that location.

\medskip\noindent
The following demonstrates the hanoi and move functions as mathematical equations.

\begin{align*}
{\rm hanoi} (1) (x) (y)
& = {\rm move}(x)(y)
\end{align*}
\begin{align*}
{\rm hanoi} (n+1) (x) (y)
& = {\rm hanoi} (n) (x) ({\rm other}(x)(y)) \\
& = {\rm move}(x)(y)\\
& = {\rm hanoi} (n) ({\rm other}(x)(y)) (y)
\end{align*}

\medskip\noindent
The following code demonstrates the recursive steps used when executing a function to solve a Hanoi tower problem of 5 disks.

\begin{lstlisting}
hanoi 5 0 2
	hanoi 4 0 1
		hanoi 3 0 2
			hanoi 2 0 1
				hanoi 1 0 2 = move 0 2
				move 0 1
				hanoi 1 2 1 = move 2 1
			move 0 2
			hanoi 2 1 2
				hanoi 1 1 0 = move 1 0
				move 1 2
				hanoi 1 0 2 = move 0 2
		move 0 1
		hanoi 3 2 1
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
			move 2 1
			hanoi 2 0 1
				hanoi 1 0 2 = move 0 2
				move 0 1
				hanoi 1 2 1 = move 2 1
	move 0 2
	hanoi 4 1 2
		hanoi 3 1 0
			hanoi 2 1 2
				hanoi 1 1 0 = move 1 0
				move 1 2
				hanoi 1 0 2 = move 0 2
			move 1 0
			hanoi 2 2 0
				hanoi 1 2 1 = move 2 1
				move 2 0
				hanoi 1 1 0 = move 1 0
		move 1 2
		hanoi 3 0 2
			hanoi 2 0 1
				hanoi 1 0 2 = move 0 2
				move 0 1
				hanoi 1 2 1 = move 2 1
			move 0 2
			hanoi 2 1 2
				hanoi 1 1 0 = move 1 0
				move 1 2
				hanoi 1 0 2 = move 0 2
\end{lstlisting}
%
These instructions count the leftmost pole as the Pole 1, the middle pole as Pole 2, and the rightmost pole as Pole 3.

\medskip\noindent
Move the top disk from Pole 1 to Pole 3. Next, move the next top disk from Pole 1 to Pole 2. Take the top disk from Pole 3 and move it to Pole 2. Then, move the top disk from Pole 1 to Pole 3. Follow by moving the top from Pole 2 to Pole 1. Then, move the top disk from Pole 2 to Pole 3. Afterwards, move the top disk from Pole 1 to Pole 3. Move the next top disk from Pole 1 to Pole 2. Next, take the top disk from Pole 3 and move it to Pole 2. Take the next top disk from Pole 3 and move it to Pole 1. Then, take the top disk from Pole 2 and move it to Pole 1. Follow by moving the top disk from Pole 3 to Pole 2. Next, move the top disk from Pole 1 to Pole 3. Then, move the next top disk from Pole 1 to Pole 2. Return to the top disk of Pole 3 and move it to Pole 2. Now, take the top disk of Pole 1 and move it to Pole 3. Next, take the top disk from Pole 2 and move it to Pole 1. Then, take the top disk from Pole 2 and move it to Pole 3. Follow by taking the top disk from Pole 1 and moving it to Pole 3. Return to Pole 2 and move its top disk to Pole 1. Now, take the top disk from Pole 3 and move it to Pole 2. Next, take the top disk from Pole 3 and move it to Pole 1. Then, take the top disk from Pole 2 and move it to Pole 1. Take the next top disk from Pole 2 and move it to Pole 3. Now, take the top disk from Pole 1 and move it to Pole 3. Return to the next top disk from Pole 1 and move it to Pole 2. Then, take the top disk from Pole 3 and move it to Pole 2. Next, take the top disk from Pole 1 and move it to Pole 3. Then, take the top disk from Pole 2 and move it to Pole 1. Move the next top disk from Pole 2 to Pole 3. Then, take the top disk from Pole 1 and move it to Pole 3. A 5-disk Tower of Hanoi has now been successfully moved from Pole 1 to Pole 3.

\medskip\noindent
The word hanoi appears 31 times in the computation.

\subsection{Week 4}

The following demonstrates the syntax trees for various arithmetic expressions. The expression being demonstrated is at the top right corner of each section, with two trees below it. The right tree is the concrete syntax tree, and the left is the abstract syntax tree.

\includegraphics {hw4}

\subsection{Week 5}

There is a folder called "hw5" in the repository that this folder is contained in. Using the grammar and interpreter contained within, I generated linearized abstract syntax trees for various Lambda expressions, then made 2D trees of them as seem below.

\includegraphics{hw5p1}
\includegraphics{hw5p2}

\medskip\noindent
Additionally, the following includes examples of various lambda expressions evaluated by hand.

\begin{lstlisting}
Expression: (\x.x) a =
a
\end{lstlisting}

\begin{lstlisting}
Expression: \x.x a =
\x.x a
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) a b =
(\y.a) b =
a
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) a b =
(\y.y) b =
b
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) a b c =
(\y.a) b c =
(a) c =
a c
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) a b c =
(\y.y) b c =
(b) c =
b c
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) a (b c) =
(\y.a) (b c) =
a
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) a (b c) =
(\y.y) (b c) =
b c
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) (a b) c =
(\y.(a b)) c =
(a b) =
a b
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) (a b) c =
(\y.y) c =
c
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.x) (a b c) =
(\y.(a b c)) =
\y.(a b c)
\end{lstlisting}

\begin{lstlisting}
Expression: (\x.\y.y) (a b c) =
(\y.y) =
\y.y
\end{lstlisting}
%
Now, I will demonstrate how the interpreter from LambdaNat0 of Assignment 2 (also found in the same repository as this report) evaluates Lambda expressions via the evalCBN function. Each step is accompanied by the line number of the Interpreter.hs code that performs that step.

\begin{lstlisting}
evalCBN ((\x.x)((\y.y)a)) = 
evalCBN (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "a")))) = Line 13
evalCBN (subst (Id "x") (EAbs (Id "y") (EVar (Id "a"))) (EVar (Id "x"))) = Line 67
evalCBN (EAbs (Id "y") (EVar (Id "a"))) = Line 13
evalCBN (subst (Id "y") (EVar (Id "a")) (EVar (Id "y"))) = Line 64
evalCBN a = Line 50
a
\end{lstlisting}

\subsection{Week 6}
\begin{lstlisting}
(\exp . \two . \three . exp two three)
(\m.\n. m n)
(\f.\x. f (f x))
(\f.\x. f (f (f x)))
=
((\m.\n. m n) (\f.\x. f (f x)) (\f2.\x2. f2 (f2 (f2 x2))))
=
((\n. (\f.\x. f (f x)) n) (\f2.\x2. f2 (f2 (f2 x2))))
=
(((\f.\x. f (f x)) (\f2.\x2. f2 (f2 (f2 x2)))))
=
(((\x. (\f2.\x2. f2 (f2 (f2 x2))) ((\f2.\x2. f2 (f2 (f2 x2))) x))))
=
(((\x. (\x2. ((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))))
=
(((\x. (\x2. ((\x2. x (x (x x2)))) (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))))
=
(((\x. (\x2. (\x2. x (x (x x2))) (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))))
=
(((\x. (\x2. (x (x (x (((\f2.\x2. f2 (f2 (f2 x2))) x) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2)))))))))
=
(((\x. (\x2. (x (x (x (((\x2. x (x (x x2)))) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2)))))))))
=
(((\x. (\x2. (x (x (x ((\x2. x (x (x x2))) (((\f2.\x2. f2 (f2 (f2 x2))) x) x2)))))))))
=
(((\x. (\x2. (x (x (x ((x (x (x (((\f2.\x2. f2 (f2 (f2 x2))) x) x2))))))))))))
=
(((\x. (\x2. (x (x (x ((x (x (x (((\x2. x (x (x x2))) x) x2))))))))))))
=
(((\x. (\x2. (x (x (x ((x (x (x (((x (x (x x)))) x2))))))))))))
=
((\x. (\x2. (x (x (x (x (x (x ((x (x (x x))) x2))))))))))
\end{lstlisting}

\subsection{Week 7}

In lines 5-7 the variables e1 and e2 are bound by evalCBN with the scope being the body of the evalCBN function. The variables i and e3 are free. In lines 18-22 the variables id1, e1, and s are bound by subst with the scope being body of the subst function. The variables f and e2 are free.

\begin{lstlisting}
evalCBN (\x.x)((\y.y)a) = line 6
evalCBN ((\y.y)a) = line 7
evalCBN (a) = line 8
a
\end{lstlisting}
\begin{lstlisting}
evalCBN (\x.\y.x) y z = line 6
evalCBN (\y.y) z = line 7
evalCBN (z) = line 8
z
\end{lstlisting}
%
Placeholder [Re-add trees later]

\subsection{Week 8}
This ARS does not terminate because the rules ba -> ab and ab -> ba will loop with each other infinitely.

\medskip\noindent
The normal forms of this ARS are a and b because those two cannot be reduced any further than their current form.

\medskip\noindent
No, because adding unique normal forms would break the looping equivalency relations caused by the rules ba -> ab and ab -> ba.

\medskip\noindent
The existint normal forms of a and b reduce duplicates into into singular forms. The ARS as a whole is a reversing function that will reverse a given string while reducing its duplicates.

\subsection{Week 9}
For my project, the two major parts will be the list generating functions and the list arithmetic functions. I will give myself the deadline of November 13th to complete the 4 list generating functions (triangle, cube, square, and fibonacci). Then, I will give myself the deadline of December 4th to complete the list artihmetic functions, but at this point they will only work with lists of the same length. I suspect that my method of augmenting lists in order to perform arithmetic between lists of different lengths will need time. Therefore, I will give myself until December 11th to figure out how to make lists of different lengths compatible in my arithmetic functions. This will give me all of finals week to do any finishing touches and complete the report details.

\medskip\noindent
The ruleset is nonterminating because the first half of the rules can be used to form an infinite loop. It is non-confluent because diverging paths taken will not meet back up, there is no way to form compatible peaks and valleys. It does not have unique normal forms because while everything does have reducible forms, there are multiple ways to reduce to b or an empty list, making them non-unique.

\medskip\noindent
The invariants are:

\medskip\noindent
length

\medskip\noindent
number of a's

\medskip\noindent
number of b's

\medskip\noindent
number of c's

\medskip\noindent
number of a's = number of b's = number of c's

\medskip\noindent
number of a's + number of c's = number of b's

\medskip\noindent
I feel like there's more after this but I'm stumped.

\subsection{Week 10}
Placeholder

\subsection{Week 11}
The following short essay discusses this paper:

\medskip\noindent
https://www.cs.tufts.edu/~nr/cs257/archive/simon-peyton-jones/contracts.pdf

\medskip\noindent
Placeholder

\subsection{Week 12}
The following section demonstrates Hoare logic analysis as applied to the code below.

\begin{lstlisting}
while (x!=0) do z:=z*y;  x:= x-1 done
\end{lstlisting}
%
We know that the program must terminate because the condition of the while loop is x not equaling 0, which x will inevitably reach on account of it being decremented with each loop. Let us assume that the variables are initialized as x = 100, y = 2, and z = 1. We will treat the variable t as a count for how many times the loop has been executed. It follows that x + t must always equal 100, as x is decremented by 1 while t is incremented by 1 with each loop. The variable y is never edited during the loop, so it will always stay at 2. The variable z is multiplied by y with each loop, being initialized as 1 but increasing to 2, then 4, then 8, then 16, and so on and so forth until the loop completes itself. This pattern reflects the exponents of 2, therefore one can write the relationship between z and y as z = y$^t$. This gives us two equations to work with.

\begin{align*}
t + x = 100
\end{align*}
\begin{align*}
z = y^t
\end{align*}
%
Logically, we can put these equations to yield a single invariant equation.

\begin{align*}
z = y^{(100 - x)}
\end{align*}
%
Now that we have the invariant, we will move on to discuss the preconditions and postconditions of our example code. The precondition of this loop running is that x must equal some positive integer above 0 and z must equal 1. The equation presented above is our postcondition that results from the termination of our program. It is worth noting that the 100 in our above invariant equation is merely a stand-in for whatever value x is initialized with. This results in the following Hoare triple.

\begin{align*}
\{x \ge 0 \: \Lambda \: z = 1\} \; {\rm while} \: (x!=0) \: {\rm do} \: z:=z*y; \: x:= x-1 \: {\rm done} \; \{z = y^x\}
\end{align*}
%
However, this only accounts for certain values of x and z. Taking the prior example initialization values of x = 100 and y = 2 but changing z to z =  5, we would see the pattern of 10, 20, 40, etc. One sees that this pattern reflects the earlier pattern except everything is now multiplied by 5. Therefore, it is better rewritten as follows to account for the variables having different values.

\begin{align*}
\{x = a \: \Lambda \: y = b \: \Lambda \: z = c\} \; {\rm while} \: (x!=0) \: {\rm do} \: z:=z*y; \: x:= x-1 \: {\rm done} \; \{z = c * b^a\}
\end{align*}

\section{Project}

Placeholder

\subsection{Specification}
I want to make a program involving infinite lists in Haskell in order to generate lists of variable size and manipulate them. There are a variety of sequences in math similar to the Fibonacci sequence, and I will implement them as separate functions. The sequences being implemented will be arithmetic, geometric, triangular, square, cube, and Fibonacci.

\medskip\noindent
Triangle, cube, square, and Fibonacci will work by taking in 1 integer number and generating a list of the sequence with the length of the given integer. For example, (fib 5) would generate a list containing the first 5 Fibonacci numbers. Arithmetic and geometric will take in 3 integer numbers. The first integer works the same as the other sequences, where it dictates the list's length. The 2nd number will be the first entry of the list and the 3rd number will be the number added to each entry. For example, (arit 3 1 6) will produce the list [1, 7, 13]. In geometric, the 2nd number works the same but 3rd number will be the number multiplied against the given value to continue the list. For example, (geo 3 1 6) will produce the list [1, 6, 36].

\medskip\noindent
These lists can have mathematical operations performed between them, which will result in a new list. The available operations will be addition, subtraction, multiplication, and integer division. When performing mathematical operations between lists of different lengths, the resulting list will be the length of the longer list. The shorter list will be extended with 0 values to fill it out to match the length of the longer list. For example, adding the lists [2, 4, 8, 16] and the list [1, 2, 3] will be the same as adding the lists [2, 4, 8, 16] and [1, 2, 3, 0], resulting in the list [3, 6, 11, 16].

\subsection{Prototype}

Placeholder

\subsection{Documentation}

Placeholder

\subsection{Critical Appraisal}

Placeholder

\section{Conclusions}\label{conclusions}

Placeholder

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\end{thebibliography}

\end{document}